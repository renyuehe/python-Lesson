# coding=utf-8
import threading
import time

# 子线程死循环
def test():
    while True:
        time.sleep(1)
        print("test\n")
        pass


t1 = threading.Thread(target=test)
t1.start()

# 主线程死循环,
while True:
    time.sleep(1)
    print("main\n")
    pass

'''
 此时新开一个终端，输入htop查看CPU占用率，可以看到两个CPU任何一个并没有全部占满，而是交替执行的：
 
 这也就验证了多线程下每个线程在执行的过程中都需要先获取GIL，保证同一时刻只有一个线程在运行。
 
 由于GIL的存在，即使是多线程，事实上同一时刻只能保证一个线程在运行，既然这样多线程的运行效率不就和单线程一样了吗，那为什么还要使用多线程呢？

 由于以前的电脑基本都是单核CPU，多线程和单线程几乎看不出差别，可是由于计算机的迅速发展，现在的电脑几乎都是多核CPU了，最少也是两个核心数的，这时差别就出来了：
 通过之前的案例我们已经知道，即使在多核CPU中，多线程同一时刻也只有一个线程在运行，这样不仅不能利用多核CPU的优势，
 反而由于每个线程在多个CPU上是交替执行的，导致在不同CPU上切换时造成资源的浪费，
 反而会更慢。即原因是一个进程只存在一把gil锁，当在执行多个线程时，
 内部会争抢gil锁，这会造成当某一个线程没有抢到锁的时候会让cpu等待，进而不能合理利用多核cpu资源。
'''

